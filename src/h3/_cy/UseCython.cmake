#.rst:
#
# The following functions are defined:
#
# .. cmake:command:: Cython_compile_pyx
#
# Create custom rules to generate the source code for a Python extension module
# using cython.
#
#   Cython_compile_pyx(<pyx_file1> [<pyx_file2> ...]
#                     [TARGET_LANGUAGE C | CXX]
#                     [LANGUAGE_LEVEL 2 | 3 | 3str]
#                     [OUTPUT_VAR <OutputVar>])
#
# Options:
#
# ``TARGET_LANGUAGE [C | CXX]``
#   Force the generation of either a C or C++ file. By default, a C file is
#   generated, unless the C language is not enabled for the project; in this
#   case, a C++ file is generated by default.
#
# ``LANGUAGE_LEVEL [2 | 3 | 3str]``
#   Force compilation using either Python-2, Python-3 or Python-3str syntax and
#   code semantics.
#   By default, Python-3str syntax and semantics are used if the major version
#   of Python found is 3 and Cython >=3 is used. Otherwise, Python-2 syntax and
#   semantics are used.
#   Using the Python-3str syntax and semantics means there cython does not assume
#   unicode is used by by default for string literals under Python 2
#
# ``OUTPUT_VAR <OutputVar>``
#   Set the variable ``<OutputVar>`` in the parent scope to the path to the
#   generated source file.  By default, ``<Name>`` is used as the output
#   variable name.
#
# Defined variables:
#
# ``<OutputVar>``
#   The path of the generated source file.
#
# Usage example:
#
# .. code-block:: cmake
#
#   find_package(Cython)
#
#   Cython_compile_pyx(_hello.pyx
#     OUTPUT_VAR _hello_source_files
#   )
#
#   Python_add_library(_hello
#     MODULE ${_hello_source_files}
#     WITH_SOABI
#   )
#
#
# .. cmake:command:: add_cython_target
#
# Create a custom rule to generate the source code for a Python extension module
# using cython.
#
#   add_cython_target(<Name> [<CythonInput>]
#                     [C | CXX]
#                     [PY2 | PY3]
#                     [OUTPUT_VAR <OutputVar>])
#
# ``<Name>`` is the name of the new target, and ``<CythonInput>``
# is the path to a cython source file.  Note that, despite the name, no new
# targets are created by this function.  Instead, see ``OUTPUT_VAR`` for
# retrieving the path to the generated source for subsequent targets.
#
# If only ``<Name>`` is provided, and it ends in the ".pyx" extension, then it
# is assumed to be the ``<CythonInput>``.  The name of the input without the
# extension is used as the target name.  If only ``<Name>`` is provided, and it
# does not end in the ".pyx" extension, then the ``<CythonInput>`` is assumed to
# be ``<Name>.pyx``.
#
# The Cython include search path is amended with any entries found in the
# ``INCLUDE_DIRECTORIES`` property of the directory containing the
# ``<CythonInput>`` file.  Use ``include_directories`` to add to the Cython
# include search path.
#
# Options:
#
# ``C | CXX``
#   Force the generation of either a C or C++ file.  By default, a C file is
#   generated, unless the C language is not enabled for the project; in this
#   case, a C++ file is generated by default.
#
# ``PY2 | PY3``
#   Force compilation using either Python-2 or Python-3 syntax and code
#   semantics.  By default, Python-2 syntax and semantics are used if the major
#   version of Python found is 2.  Otherwise, Python-3 syntax and semantics are
#   used.
#
# ``OUTPUT_VAR <OutputVar>``
#   Set the variable ``<OutputVar>`` in the parent scope to the path to the
#   generated source file.  By default, ``<Name>`` is used as the output
#   variable name.
#
# Defined variables:
#
# ``<OutputVar>``
#   The path of the generated source file.
#
# Cache variables that affect the behavior include:
#
# ``CYTHON_ANNOTATE``
#   Whether to create an annotated .html file when compiling.
#
# ``CYTHON_FLAGS``
#   Additional flags to pass to the Cython compiler.
#
# Usage example:
#
# .. code-block:: cmake
#
#   find_package(Cython)
#
#   # Note: In this case, either one of these arguments may be omitted; their
#   # value would have been inferred from that of the other.
#   add_cython_target(cy_code cy_code.pyx)
#
#   add_library(cy_code MODULE ${cy_code})
#   target_link_libraries(cy_code ...)
#
#=============================================================================
# Copyright 2011 Kitware, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#=============================================================================


function(add_cython_target _name)
  set(_options C CXX PY2 PY3)
  set(_one_value OUTPUT_VAR)
  set(_multi_value )

  cmake_parse_arguments(_args
    "${_options}"
    "${_one_value}"
    "${_multi_value}"
    ${ARGN}
    )

  # Configuration options.
  set(CYTHON_ANNOTATE OFF
      CACHE BOOL "Create an annotated .html file when compiling *.pyx.")

  set(CYTHON_FLAGS "" CACHE STRING
      "Extra flags to the cython compiler.")
  mark_as_advanced(CYTHON_ANNOTATE CYTHON_FLAGS)

  if(_args_C)
    set(_target_language "C")
  endif()
  if(_args_CXX)
    set(_target_language "CXX")
  endif()

  if(_args_PY2)
    set(_language_level "2")
  endif()
  if(_args_PY3)
    set(_language_level "3")
  endif()

  list(GET _args_UNPARSED_ARGUMENTS 0 _arg0)

  # if provided, use _arg0 as the input file path
  if(_arg0)
    set(_source_file ${_arg0})

  # otherwise, must determine source file from name, or vice versa
  else()
    get_filename_component(_name_ext "${_name}" EXT)

    # if extension provided, _name is the source file
    if(_name_ext)
      set(_source_file ${_name})
      get_filename_component(_name "${_source_file}" NAME_WE)

    # otherwise, assume the source file is ${_name}.pyx
    else()
      set(_source_file ${_name}.pyx)
    endif()
  endif()

  # Set additional flags.
  set(_cython_args)
  if(CYTHON_ANNOTATE)
    list(APPEND _cython_args "--annotate")
  endif()
  if(CMAKE_BUILD_TYPE STREQUAL "Debug" OR
      CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
    list(APPEND _cython_args
      "--gdb"
      "--line-directives"
    )
  endif()
  string(STRIP "${CYTHON_FLAGS}" _stripped_cython_flags)
  if(_stripped_cython_flags)
    string(REGEX REPLACE " " ";" CYTHON_FLAGS_LIST "${_stripped_cython_flags}")
    list(APPEND _cython_args ${CYTHON_FLAGS_LIST})
  endif()

  Cython_compile_pyx(
    TARGET_LANGUAGE ${_target_language}
    LANGUAGE_LEVEL ${_language_level}
    CYTHON_ARGS ${_cython_args}
    OUTPUT_VAR ${_args_OUTPUT_VAR}
    ${_source_file}
    )

  if(_args_OUTPUT_VAR)
    set(${_args_OUTPUT_VAR} ${${_args_OUTPUT_VAR}} PARENT_SCOPE)
  endif()
endfunction()

function(Cython_compile_pyx)
  set(_options )
  set(_one_value LANGUAGE_LEVEL TARGET_LANGUAGE OUTPUT_VAR)
  set(_multi_value CYTHON_ARGS)

  cmake_parse_arguments(_args
    "${_options}"
    "${_one_value}"
    "${_multi_value}"
    ${ARGN}
    )

  # Get source file location
  set(_source_files ${_args_UNPARSED_ARGUMENTS})

  # Set target language
  get_property(_languages GLOBAL PROPERTY ENABLED_LANGUAGES)
  set(_target_language ${_args_TARGET_LANGUAGE})
  if(NOT _target_language)
    if("C" IN_LIST _languages)
      set(_target_language "C")
    elseif("CXX" IN_LIST _languages)
      set(_target_language "CXX")
    endif()
  else()
    if(NOT _target_language MATCHES "^(C|CXX)$")
      message(FATAL_ERROR "TARGET_LANGUAGE must be one of C or CXX")
    endif()
  endif()

  set(_target_language_C_arg "")
  set(_target_language_C_extension "c")
  set(_target_language_CXX_arg "--cplus")
  set(_target_language_CXX_extension "cxx")

  set(_target_language_arg ${_target_language_${_target_language}_arg})
  set(_target_language_extension ${_target_language_${_target_language}_extension})

  # Set language level
  set(_language_level ${_args_LANGUAGE_LEVEL})
  if(NOT _args_LANGUAGE_LEVEL)
    set(_language_level "3str")
  else()
    if(NOT _language_level MATCHES "^(2|3|3str)$")
      message(FATAL_ERROR "LANGUAGE_LEVEL must be one of 2, 3, or 3str")
    endif()
  endif()

  set(_language_level_2_arg "-2")
  set(_language_level_3_arg "-3")
  set(_language_level_3str_arg "--3str")

  set(_language_level_arg "${_language_level_${_language_level}_arg}")

  # Generated depfile is expected to have the ".dep" extension and be located along
  # side the generated source file.
  set(_depfile ${generated_file}.dep)
  set(_depfile_arg "-M")

  set(generated_files)

  foreach(_source_file IN LISTS _source_files)
    cmake_path(GET _source_file STEM _name)
    set(generated_file "${CMAKE_CURRENT_BINARY_DIR}/${_name}.${_target_language_extension}")
    set_source_files_properties(${generated_file} PROPERTIES GENERATED TRUE)

    file(RELATIVE_PATH generated_file_relative
        ${CMAKE_BINARY_DIR} ${generated_file})

    set(comment "Generating ${_target_language} source ${generated_file_relative}")

    get_source_file_property(pyx_location ${_source_file} LOCATION)

    # Add the command to run the compiler.
    add_custom_command(
      OUTPUT ${generated_file}
      COMMAND ${CYTHON_EXECUTABLE}
      ARGS
        ${_target_language_arg}
        ${_language_level_arg}
        ${_args_CYTHON_ARGS}
        ${_depfile_arg}
        ${pyx_location}
        --output-file ${generated_file}
      DEPENDS
        ${_source_file}
      DEPFILE
        ${_cython_depfile}
      VERBATIM
      COMMENT ${comment}
    )
    list(APPEND generated_files ${generated_file})
  endforeach()

  if(_args_OUTPUT_VAR)
    set(_output_var ${_args_OUTPUT_VAR})
    set(${_output_var} ${generated_files} PARENT_SCOPE)
  endif()

endfunction()

